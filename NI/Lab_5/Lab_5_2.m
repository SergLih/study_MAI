%Использование сети Хопфилда для распознавания статических образов
%[0,9,2]
     
number0 = [-1 -1 -1 -1 -1 -1 -1 -1 -1 -1;
           -1 -1 -1 +1 +1 +1 +1 -1 -1 -1;
           -1 -1 +1 +1 +1 +1 +1 +1 -1 -1;
           -1 +1 +1 +1 -1 -1 +1 +1 +1 -1;
           -1 +1 +1 +1 -1 -1 +1 +1 +1 -1;
           -1 +1 +1 +1 -1 -1 +1 +1 +1 -1;
           -1 +1 +1 +1 -1 -1 +1 +1 +1 -1;
           -1 +1 +1 +1 -1 -1 +1 +1 +1 -1;
           -1 +1 +1 +1 -1 -1 +1 +1 +1 -1;
           -1 -1 +1 +1 +1 +1 +1 +1 -1 -1;
           -1 -1 -1 +1 +1 +1 +1 -1 -1 -1;
           -1 -1 -1 -1 -1 -1 -1 -1 -1 -1];

number2 = [+1 +1 +1 +1 +1 +1 +1 +1 -1 -1;
           +1 +1 +1 +1 +1 +1 +1 +1 -1 -1;
           -1 -1 -1 -1 -1 -1 +1 +1 -1 -1;
           -1 -1 -1 -1 -1 -1 +1 +1 -1 -1;
           -1 -1 -1 -1 -1 -1 +1 +1 -1 -1;
           +1 +1 +1 +1 +1 +1 +1 +1 -1 -1;
           +1 +1 +1 +1 +1 +1 +1 +1 -1 -1;
           +1 +1 -1 -1 -1 -1 -1 -1 -1 -1;
           +1 +1 -1 -1 -1 -1 -1 -1 -1 -1;
           +1 +1 -1 -1 -1 -1 -1 -1 -1 -1;
           +1 +1 +1 +1 +1 +1 +1 +1 -1 -1;
           +1 +1 +1 +1 +1 +1 +1 +1 -1 -1;];
       
number9 = [-1 -1 -1 -1 +1 +1 +1 +1 +1 +1;
           -1 -1 -1 -1 +1 +1 +1 +1 +1 +1;
           -1 -1 -1 -1 +1 +1 -1 -1 +1 +1;
           -1 -1 -1 -1 +1 +1 -1 -1 +1 +1;
           -1 -1 -1 -1 +1 +1 -1 -1 +1 +1;
           -1 -1 -1 -1 +1 +1 -1 -1 +1 +1;
           -1 -1 -1 -1 +1 +1 +1 +1 +1 +1;
           -1 -1 -1 -1 +1 +1 +1 +1 +1 +1;
           -1 -1 -1 -1 -1 -1 -1 -1 +1 +1;
           -1 -1 -1 -1 -1 -1 -1 -1 +1 +1;
           -1 -1 -1 -1 +1 +1 +1 +1 +1 +1;
           -1 -1 -1 -1 +1 +1 +1 +1 +1 +1];

       
%2.1 Создание сети
P = [number2(:), number0(:), number9(:)];
net = newhop(P);

%2.2 Подача образа на вход, расчет выхода
iterations = 600;
R = sim(net, {1 iterations}, {}, number2(:));
R = reshape(R{iterations}, 12, 10);
R(R >=0 ) = 2;
R(R < 0 ) = 1;

map = [1, 1, 1; 0, 0, 0];
image(R);
colormap(map)
axis off
axis image

%2.3 Подача зашумленного образа(20%) на вход, расчет выхода
%Зашумление
r = rand([12,10]);
M = 0.2;
in = number0;
for i=1:12
    for j = 1:10
        if r(i,j) < M
            in(i,j) = -in(i,j);
        end
    end
end

%Отображаем зашумленный образ
R = reshape(in, 12, 10);
R(R >= 0) = 2;
R(R < 0) = 1;
map = [1, 1, 1; 0, 0, 0];
figure('Name', '0');
image(R);
colormap(map)
axis off
axis image

%Распознавание зашумленного образа
iterations = 600;
R = sim(net, {1 iterations},  {}, in(:));
R = reshape(R{iterations}, 12, 10);
R(R >=0 ) = 2;
R(R < 0 ) = 1;
map = [1, 1, 1; 0, 0, 0];
figure;
image(R);
colormap(map)
axis off
axis image

%2.4 Подача зашумленного образа(30%) на вход, расчет выхода
%Зашумление
r = rand([12,10]);
M = 0.3;
in = number9;
for i=1:12
    for j = 1:10
        if r(i,j) < M
            in(i,j) = -in(i,j);
        end
    end
end

%Отображаем зашумленный образ
R = reshape(in, 12, 10);
R(R >= 0) = 2;
R(R < 0) = 1;
map = [1, 1, 1; 0, 0, 0];
figure('Name', '4');
image(R);
colormap(map)
axis off
axis image

%Распознавание зашумленного образа
iterations = 600;
R = sim(net, {1 iterations},  {}, in(:));
R = reshape(R{iterations}, 12, 10);
R(R >=0 ) = 2;
R(R < 0 ) = 1;
map = [1, 1, 1; 0, 0, 0];
figure;
image(R);
colormap(map)
axis off
axis image